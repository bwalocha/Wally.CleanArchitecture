using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

using FluentAssertions;
using FluentAssertions.Execution;
using FluentAssertions.Types;

using MassTransit;

using MediatR;

using Wally.CleanArchitecture.MicroService.ConventionTests.Helpers;

using Xunit;

namespace Wally.CleanArchitecture.MicroService.ConventionTests;

public class AsyncTests
{
	[Fact]
	public void AsyncMethods_ShouldHaveCancellationTokenAsLastParam()
	{
		using (new AssertionScope(new AssertionStrategy()))
		{
			foreach (var assembly in Configuration.Assemblies.GetAllAssemblies())
			{
				// TODO: Consider to exclude anonymous types in different way
				var types = AllTypes.From(assembly)
					.Where(a => !a.Name.Contains("<>"));

				foreach (var type in types)
				{
					foreach (var method in type.Methods()
								.Where(
									a => a.ReturnType == typeof(Task) ||
										a.ReturnType.InheritsGenericClass(typeof(Task<>)) ||
										a.GetCustomAttribute(typeof(AsyncStateMachineAttribute)) != null))
					{
						if (method.Name.StartsWith("<>"))
						{
							// skip testing AutoGenerated method
							continue;
						}

						if (method.GetBaseDefinition()
								.DeclaringType != method.DeclaringType)
						{
							// skip testing Override method
							continue;
						}

						if (type.ImplementsGenericInterface(typeof(IPipelineBehavior<,>)) &&
							method.Name == nameof(IPipelineBehavior<IRequest<object>, object>.Handle))
						{
							continue;
						}

						if (type.ImplementsGenericInterface(typeof(IConsumer<>)) &&
							method.Name == nameof(IConsumer<object>.Consume))
						{
							continue;
						}

						var parameters = method.GetParameters();

						parameters.LastOrDefault()
							?.ParameterType.Should()
							.Be<CancellationToken>(
								"Method '{0}' should contain cancellation token as the last param in type '{1}'",
								method,
								type);
					}
				}
			}
		}
	}

	[Fact]
	public void AsyncMethods_ShouldHaveAsyncSuffix()
	{
		using (new AssertionScope(new AssertionStrategy()))
		{
			foreach (var assembly in Configuration.Assemblies.GetAllAssemblies())
			{
				// TODO: Consider to exclude anonymous types in different way
				var types = AllTypes.From(assembly)
					.Where(a => !a.Name.Contains("<>"));

				foreach (var type in types)
				{
					foreach (var method in type.Methods()
								.Where(
									a => a.ReturnType == typeof(Task) ||
										a.ReturnType.InheritsGenericClass(typeof(Task<>)) ||
										a.GetCustomAttribute(typeof(AsyncStateMachineAttribute)) != null))
					{
						if (method.Name.StartsWith("<>"))
						{
							// skip testing AutoGenerated method
							continue;
						}

						if (method.GetBaseDefinition()
								.DeclaringType != method.DeclaringType)
						{
							continue;
						}

						if (type.ImplementsGenericInterface(typeof(IPipelineBehavior<,>)) &&
							method.Name == nameof(IPipelineBehavior<IRequest<object>, object>.Handle))
						{
							continue;
						}

						if (type.ImplementsGenericInterface(typeof(IConsumer<>)) &&
							method.Name == nameof(IConsumer<object>.Consume))
						{
							continue;
						}

						method.Name.Should()
							.EndWith("Async", "Method '{0}' in type '{1}' should contain Async suffix ", method, type);
					}
				}
			}
		}
	}
}
