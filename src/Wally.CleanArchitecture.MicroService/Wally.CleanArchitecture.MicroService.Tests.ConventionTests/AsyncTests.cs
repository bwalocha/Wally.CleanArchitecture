using System;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using MassTransit;
using Mediator;
using Microsoft.AspNetCore.SignalR;
using Wally.CleanArchitecture.MicroService.Application.Abstractions;
using Wally.CleanArchitecture.MicroService.Tests.ConventionTests.Extensions;

namespace Wally.CleanArchitecture.MicroService.Tests.ConventionTests;

public class AsyncTests
{
	[Fact]
	public void AsyncMethods_ShouldHaveCancellationTokenAsLastParam()
	{
		var assemblies = Configuration.Assemblies.GetAllAssemblies();
		var types = assemblies.GetAllTypes();

		types.ShouldSatisfyAllConditions(
			() =>
			{
				foreach (var type in types)
				{
					foreach (var method in type.GetMethods()
								.Where(
									a => a.ReturnType == typeof(Task) ||
										a.ReturnType.InheritsGenericClass(typeof(Task<>)) ||
										a.GetCustomAttribute(typeof(AsyncStateMachineAttribute)) != null))
					{
						if (method.DeclaringType != type)
						{
							// skip base method
							continue;
						}

						if (method.Name.StartsWith("<>"))
						{
							// skip testing AutoGenerated method
							continue;
						}

						if (type.ImplementsGenericInterface(typeof(IConsumer<>)) &&
							method.Name == nameof(IConsumer<object>.Consume))
						{
							continue;
						}

						if (type.InheritsGenericClass(typeof(Hub<>)) &&
							method.Name == nameof(Hub<object>.OnConnectedAsync))
						{
							continue;
						}

						if (type.InheritsGenericClass(typeof(Hub<>)) &&
							method.Name == nameof(Hub<object>.OnDisconnectedAsync))
						{
							continue;
						}

						var parameters = method.GetParameters();

						parameters.LastOrDefault()?.ParameterType
							.ShouldBe(typeof(CancellationToken), $"Method '{method}' should contain Cancellation Token as the last parameter in the type '{type}'");
					}
				}
			});
	}

	[Fact]
	public void AsyncMethods_ShouldHaveNameSuffix()
	{
		// Assign
		var assemblies = Configuration.Assemblies.GetAllAssemblies();
		var types = assemblies.GetAllTypes();

		// Act
		Action Act(Type type) =>
			() =>
			{
				foreach (var method in type.GetMethods()
							.Where(
								a => a.ReturnType == typeof(Task) ||
									a.ReturnType.InheritsGenericClass(typeof(Task<>)) ||
									a.GetCustomAttribute(typeof(AsyncStateMachineAttribute)) != null))
				{
					if (method.DeclaringType != type)
					{
						// skip base method
						continue;
					}
						
					if (method.Name.StartsWith('<'))
					{
						// skip testing AutoGenerated method
						continue;
					}

					if (method.GetBaseDefinition()
							.DeclaringType != method.DeclaringType)
					{
						continue;
					}

					if (type.ImplementsGenericInterface(typeof(IPipelineBehavior<,>)) &&
						method.Name == nameof(IPipelineBehavior<IRequest<object>, object>.Handle))
					{
						continue;
					}

					if (type.ImplementsGenericInterface(typeof(IConsumer<>)) &&
						method.Name == nameof(IConsumer<object>.Consume))
					{
						continue;
					}

					if (type == typeof(CommandHandler<>))
					{
						continue;
					}

					if (type == typeof(CommandHandler<,>))
					{
						continue;
					}

					if (type == typeof(QueryHandler<,>))
					{
						continue;
					}

					method.Name.ShouldEndWith("Async", Case.Sensitive,
						$"Async method '{method}' name of type '{type}' should end with 'Async'");
				}
			};
		
		// Assert
		types.ShouldSatisfyAllConditions(types.Select((Func<Type, Action>)Act).ToArray());
	}
}
