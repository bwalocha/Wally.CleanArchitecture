using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using MassTransit;
using MediatR;
using Microsoft.AspNetCore.SignalR;
using Shouldly;
using Wally.CleanArchitecture.MicroService.Application.Abstractions;
using Wally.CleanArchitecture.MicroService.Tests.ConventionTests.Extensions;
using Xunit;

namespace Wally.CleanArchitecture.MicroService.Tests.ConventionTests;

public class AsyncTests
{
	[Fact]
	public void AsyncMethods_ShouldHaveCancellationTokenAsLastParam()
	{
		var assemblies = Configuration.Assemblies.GetAllAssemblies();
		var types = assemblies.GetAllExportedTypes();

		types.ShouldSatisfyAllConditions(
			() =>
			{
				foreach (var type in types)
				{
					foreach (var method in type.GetMethods()
								.Where(
									a => a.ReturnType == typeof(Task) ||
										a.ReturnType.InheritsGenericClass(typeof(Task<>)) ||
										a.GetCustomAttribute(typeof(AsyncStateMachineAttribute)) != null))
					{
						if (method.Name.StartsWith("<>"))
						{
							// skip testing AutoGenerated method
							continue;
						}

						if (type.ImplementsGenericInterface(typeof(IConsumer<>)) &&
							method.Name == nameof(IConsumer<object>.Consume))
						{
							continue;
						}

						if (type.InheritsGenericClass(typeof(Hub<>)) &&
							method.Name == nameof(Hub<object>.OnConnectedAsync))
						{
							continue;
						}

						if (type.InheritsGenericClass(typeof(Hub<>)) &&
							method.Name == nameof(Hub<object>.OnDisconnectedAsync))
						{
							continue;
						}

						var parameters = method.GetParameters();

						parameters.LastOrDefault()
							?.ParameterType
							.ShouldBeOfType<CancellationToken>($"Method '{method}' should contain cancellation token as the last param in type '{type}'");
					}
				}
			});
	}

	[Fact]
	public void AsyncMethods_ShouldHaveAsyncSuffix()
	{
		var assemblies = Configuration.Assemblies.GetAllAssemblies();
		var types = assemblies.GetAllExportedTypes();

		types.ShouldSatisfyAllConditions(
			() =>
			{
				foreach (var type in types)
				{
					foreach (var method in type.GetMethods()
								.Where(
									a => a.ReturnType == typeof(Task) ||
										a.ReturnType.InheritsGenericClass(typeof(Task<>)) ||
										a.GetCustomAttribute(typeof(AsyncStateMachineAttribute)) != null))
					{
						if (method.Name.StartsWith('<'))
						{
							// skip testing AutoGenerated method
							continue;
						}

						if (method.GetBaseDefinition()
								.DeclaringType != method.DeclaringType)
						{
							continue;
						}

						if (type.ImplementsGenericInterface(typeof(IPipelineBehavior<,>)) &&
							method.Name == nameof(IPipelineBehavior<IRequest<object>, object>.Handle))
						{
							continue;
						}

						if (type.ImplementsGenericInterface(typeof(IConsumer<>)) &&
							method.Name == nameof(IConsumer<object>.Consume))
						{
							continue;
						}

						if (type == typeof(CommandHandler<>))
						{
							continue;
						}

						if (type == typeof(CommandHandler<,>))
						{
							continue;
						}

						if (type == typeof(QueryHandler<,>))
						{
							continue;
						}

						method.Name.ShouldEndWith("Async", Case.Sensitive,
							$"Method '{method}' in type '{type}' should contain Async suffix");
					}
				}
			});
		}
}
